/**
 * Content Generator - Procedural content for ISO variable layer
 * 
 * Generates deterministic content that makes each ISO unique:
 * - Text documents (READMEs, man pages, config files)
 * - Binary data (wallpapers, icons, fonts)
 * - System files (machine-id, logs, cache)
 * - Padding data
 */

// Content type identifiers
export const CONTENT_TYPES = {
  TEXT_README: 0x01,
  TEXT_CONFIG: 0x02,
  TEXT_MANPAGE: 0x03,
  TEXT_LOG: 0x04,
  BINARY_WALLPAPER: 0x10,
  BINARY_ICON: 0x11,
  BINARY_FONT: 0x12,
  SYSTEM_MACHINE_ID: 0x20,
  SYSTEM_FSTAB: 0x21,
  SYSTEM_HOSTNAME: 0x22,
  PADDING: 0xFF
}

// Word lists for procedural text
const ADJECTIVES = [
  'fast', 'secure', 'private', 'decentralized', 'sovereign', 'free',
  'open', 'distributed', 'resilient', 'anonymous', 'encrypted', 'mesh',
  'peer', 'autonomous', 'trustless', 'permissionless', 'censorship-resistant'
]

const NOUNS = [
  'network', 'node', 'system', 'protocol', 'infrastructure', 'platform',
  'service', 'daemon', 'process', 'module', 'component', 'layer',
  'stack', 'framework', 'runtime', 'kernel', 'filesystem', 'storage'
]

const VERBS = [
  'connects', 'synchronizes', 'validates', 'propagates', 'routes',
  'encrypts', 'decrypts', 'stores', 'retrieves', 'broadcasts',
  'relays', 'verifies', 'authenticates', 'authorizes', 'distributes'
]

const TECH_TERMS = [
  'DHT', 'P2P', 'WebRTC', 'WebSocket', 'TCP', 'UDP', 'TLS', 'QUIC',
  'Ed25519', 'X25519', 'ChaCha20', 'Poly1305', 'SHA-256', 'BLAKE3',
  'Merkle tree', 'bloom filter', 'consistent hashing', 'gossip protocol'
]

/**
 * Generate procedural text content
 */
function generateText (rng, minLength) {
  const paragraphs = []
  let totalLength = 0
  
  while (totalLength < minLength) {
    const para = generateParagraph(rng)
    paragraphs.push(para)
    totalLength += para.length + 2 // +2 for \n\n
  }
  
  return paragraphs.join('\n\n')
}

function generateParagraph (rng) {
  const sentenceCount = 3 + rng.int(5)
  const sentences = []
  
  for (let i = 0; i < sentenceCount; i++) {
    sentences.push(generateSentence(rng))
  }
  
  return sentences.join(' ')
}

function generateSentence (rng) {
  const patterns = [
    () => `The ${rng.pick(ADJECTIVES)} ${rng.pick(NOUNS)} ${rng.pick(VERBS)} data across the ${rng.pick(NOUNS)}.`,
    () => `Using ${rng.pick(TECH_TERMS)}, the ${rng.pick(NOUNS)} achieves ${rng.pick(ADJECTIVES)} ${rng.pick(NOUNS)} capabilities.`,
    () => `This ${rng.pick(ADJECTIVES)} ${rng.pick(NOUNS)} ${rng.pick(VERBS)} with other ${rng.pick(NOUNS)}s in the network.`,
    () => `${rng.pick(TECH_TERMS)} enables ${rng.pick(ADJECTIVES)} communication between ${rng.pick(NOUNS)}s.`,
    () => `The ${rng.pick(NOUNS)} layer ${rng.pick(VERBS)} all ${rng.pick(ADJECTIVES)} ${rng.pick(NOUNS)} traffic.`,
    () => `For ${rng.pick(ADJECTIVES)} operation, the ${rng.pick(NOUNS)} uses ${rng.pick(TECH_TERMS)}.`
  ]
  
  return rng.pick(patterns)()
}

/**
 * Generate README-style document
 */
function generateReadme (rng) {
  const projectName = `${rng.pick(ADJECTIVES)}-${rng.pick(NOUNS)}`.toUpperCase().replace(/-/g, '_')
  const version = `${rng.int(10)}.${rng.int(20)}.${rng.int(100)}`
  
  let content = `# ${projectName}\n\n`
  content += `Version ${version}\n\n`
  content += `## Overview\n\n`
  content += generateParagraph(rng) + '\n\n'
  content += `## Features\n\n`
  
  const featureCount = 3 + rng.int(5)
  for (let i = 0; i < featureCount; i++) {
    content += `- ${rng.pick(ADJECTIVES).charAt(0).toUpperCase() + rng.pick(ADJECTIVES).slice(1)} ${rng.pick(NOUNS)} support\n`
  }
  
  content += `\n## Installation\n\n`
  content += '```bash\n'
  content += `./configure --prefix=/usr\nmake\nmake install\n`
  content += '```\n\n'
  
  content += `## Configuration\n\n`
  content += generateParagraph(rng) + '\n\n'
  
  content += `## License\n\n`
  content += `This software is released under the MIT License.\n`
  
  return content
}

/**
 * Generate config file
 */
function generateConfig (rng) {
  let content = `# Configuration file generated by ISO Forge\n`
  content += `# Seed: ${rng.bytes(8).toString('hex')}\n\n`
  
  const sections = ['network', 'storage', 'security', 'logging', 'performance']
  
  for (const section of rng.shuffle([...sections]).slice(0, 3 + rng.int(3))) {
    content += `[${section}]\n`
    
    const optionCount = 2 + rng.int(5)
    for (let i = 0; i < optionCount; i++) {
      const key = `${rng.pick(ADJECTIVES)}_${rng.pick(NOUNS)}`.toLowerCase().replace(/-/g, '_')
      const valueType = rng.int(4)
      let value
      
      switch (valueType) {
        case 0: value = rng.int(65536).toString(); break
        case 1: value = (rng.float() > 0.5).toString(); break
        case 2: value = `"${rng.pick(TECH_TERMS)}"`; break
        case 3: value = `0x${rng.bytes(4).toString('hex')}`; break
      }
      
      content += `${key} = ${value}\n`
    }
    content += '\n'
  }
  
  return content
}

/**
 * Generate man page
 */
function generateManPage (rng) {
  const name = `${rng.pick(NOUNS)}d`
  const section = 1 + rng.int(8)
  
  let content = `.TH ${name.toUpperCase()} ${section} "2024-01-01" "Supernode" "Supernode Manual"\n`
  content += `.SH NAME\n`
  content += `${name} \\- ${rng.pick(ADJECTIVES)} ${rng.pick(NOUNS)} daemon\n`
  content += `.SH SYNOPSIS\n`
  content += `.B ${name}\n`
  content += `[\\fB\\-c\\fR \\fIconfig\\fR]\n`
  content += `[\\fB\\-d\\fR]\n`
  content += `[\\fB\\-v\\fR]\n`
  content += `.SH DESCRIPTION\n`
  content += `.B ${name}\n`
  content += `${rng.pick(VERBS)} ${rng.pick(NOUNS)} data using ${rng.pick(TECH_TERMS)}.\n`
  content += generateParagraph(rng).replace(/\. /g, '.\n') + '\n'
  content += `.SH OPTIONS\n`
  content += `.TP\n.B \\-c \\fIconfig\\fR\nSpecify configuration file.\n`
  content += `.TP\n.B \\-d\nRun as daemon.\n`
  content += `.TP\n.B \\-v\nVerbose output.\n`
  content += `.SH SEE ALSO\n`
  content += `.BR ${rng.pick(NOUNS)}ctl (1),\n.BR ${rng.pick(NOUNS)}.conf (5)\n`
  
  return content
}

/**
 * Generate log file content
 */
function generateLog (rng, size) {
  let content = ''
  const startTime = Date.now() - rng.int(86400000) // Up to 24 hours ago
  let currentTime = startTime
  
  const levels = ['INFO', 'DEBUG', 'WARN', 'ERROR']
  const levelWeights = [0.6, 0.25, 0.1, 0.05]
  
  while (content.length < size) {
    const date = new Date(currentTime)
    const timestamp = date.toISOString()
    
    // Weighted level selection
    const r = rng.float()
    let level = 'INFO'
    let cumulative = 0
    for (let i = 0; i < levels.length; i++) {
      cumulative += levelWeights[i]
      if (r < cumulative) {
        level = levels[i]
        break
      }
    }
    
    const component = rng.pick(NOUNS)
    const action = rng.pick(VERBS)
    const detail = `${rng.pick(ADJECTIVES)} ${rng.pick(NOUNS)}`
    
    content += `${timestamp} [${level}] ${component}: ${action} ${detail}\n`
    currentTime += rng.int(5000) + 100 // 100ms to 5s between log lines
  }
  
  return content
}

/**
 * Generate BMP wallpaper (simple gradient)
 */
function generateWallpaper (rng, width = 640, height = 480) {
  // BMP file header (14 bytes)
  const fileHeaderSize = 14
  const dibHeaderSize = 40 // BITMAPINFOHEADER
  const rowSize = Math.ceil((width * 3) / 4) * 4 // Rows padded to 4-byte boundary
  const pixelDataSize = rowSize * height
  const fileSize = fileHeaderSize + dibHeaderSize + pixelDataSize
  
  const buffer = Buffer.alloc(fileSize)
  let offset = 0
  
  // BMP file header
  buffer.write('BM', offset); offset += 2
  buffer.writeUInt32LE(fileSize, offset); offset += 4
  buffer.writeUInt16LE(0, offset); offset += 2 // Reserved
  buffer.writeUInt16LE(0, offset); offset += 2 // Reserved
  buffer.writeUInt32LE(fileHeaderSize + dibHeaderSize, offset); offset += 4 // Pixel data offset
  
  // DIB header (BITMAPINFOHEADER)
  buffer.writeUInt32LE(dibHeaderSize, offset); offset += 4
  buffer.writeInt32LE(width, offset); offset += 4
  buffer.writeInt32LE(height, offset); offset += 4
  buffer.writeUInt16LE(1, offset); offset += 2 // Color planes
  buffer.writeUInt16LE(24, offset); offset += 2 // Bits per pixel
  buffer.writeUInt32LE(0, offset); offset += 4 // Compression (none)
  buffer.writeUInt32LE(pixelDataSize, offset); offset += 4
  buffer.writeInt32LE(2835, offset); offset += 4 // Horizontal resolution (72 DPI)
  buffer.writeInt32LE(2835, offset); offset += 4 // Vertical resolution
  buffer.writeUInt32LE(0, offset); offset += 4 // Colors in palette
  buffer.writeUInt32LE(0, offset); offset += 4 // Important colors
  
  // Generate gradient colors
  const color1 = {
    r: rng.int(256),
    g: rng.int(256),
    b: rng.int(256)
  }
  const color2 = {
    r: rng.int(256),
    g: rng.int(256),
    b: rng.int(256)
  }
  
  // Pixel data (bottom-up, BGR format)
  for (let y = 0; y < height; y++) {
    const rowOffset = fileHeaderSize + dibHeaderSize + y * rowSize
    for (let x = 0; x < width; x++) {
      const t = (x + y) / (width + height)
      const r = Math.floor(color1.r * (1 - t) + color2.r * t)
      const g = Math.floor(color1.g * (1 - t) + color2.g * t)
      const b = Math.floor(color1.b * (1 - t) + color2.b * t)
      
      buffer[rowOffset + x * 3 + 0] = b
      buffer[rowOffset + x * 3 + 1] = g
      buffer[rowOffset + x * 3 + 2] = r
    }
  }
  
  return buffer
}

/**
 * Generate machine-id (32 hex chars)
 */
function generateMachineId (rng) {
  return rng.bytes(16).toString('hex') + '\n'
}

/**
 * Generate fstab
 */
function generateFstab (rng) {
  let content = '# /etc/fstab: static file system information\n'
  content += '#\n'
  content += '# <file system>  <mount point>  <type>  <options>  <dump>  <pass>\n'
  content += '/dev/sda1        /              ext4    defaults   0       1\n'
  content += '/dev/sda2        none           swap    sw         0       0\n'
  content += 'tmpfs            /tmp           tmpfs   defaults   0       0\n'
  
  if (rng.float() > 0.5) {
    const uuid = rng.bytes(16).toString('hex')
    content += `UUID=${uuid.slice(0,8)}-${uuid.slice(8,12)}-${uuid.slice(12,16)}-${uuid.slice(16,20)}-${uuid.slice(20,32)} /data ext4 defaults 0 2\n`
  }
  
  return content
}

/**
 * Generate hostname
 */
function generateHostname (rng) {
  const prefixes = ['node', 'mesh', 'peer', 'relay', 'seed', 'super']
  const prefix = rng.pick(prefixes)
  const suffix = rng.bytes(4).toString('hex')
  return `${prefix}-${suffix}\n`
}

/**
 * Main content generation function
 * Fills a buffer with procedural content
 */
export function generateContent (rng, targetSize) {
  const buffer = Buffer.alloc(targetSize)
  let offset = 0
  
  // Generate various content types
  const contentPlan = [
    { type: CONTENT_TYPES.TEXT_README, gen: () => Buffer.from(generateReadme(rng.derive('readme'))) },
    { type: CONTENT_TYPES.TEXT_CONFIG, gen: () => Buffer.from(generateConfig(rng.derive('config'))) },
    { type: CONTENT_TYPES.TEXT_MANPAGE, gen: () => Buffer.from(generateManPage(rng.derive('manpage'))) },
    { type: CONTENT_TYPES.TEXT_LOG, gen: () => Buffer.from(generateLog(rng.derive('log'), 4096)) },
    { type: CONTENT_TYPES.BINARY_WALLPAPER, gen: () => generateWallpaper(rng.derive('wallpaper')) },
    { type: CONTENT_TYPES.SYSTEM_MACHINE_ID, gen: () => Buffer.from(generateMachineId(rng.derive('machine-id'))) },
    { type: CONTENT_TYPES.SYSTEM_FSTAB, gen: () => Buffer.from(generateFstab(rng.derive('fstab'))) },
    { type: CONTENT_TYPES.SYSTEM_HOSTNAME, gen: () => Buffer.from(generateHostname(rng.derive('hostname'))) }
  ]
  
  // Generate planned content
  for (const item of contentPlan) {
    if (offset >= targetSize) break
    
    const content = item.gen()
    const toCopy = Math.min(content.length, targetSize - offset)
    content.copy(buffer, offset, 0, toCopy)
    offset += toCopy
    
    // Add padding between content
    const paddingSize = Math.min(rng.int(1024), targetSize - offset)
    if (paddingSize > 0) {
      const padding = rng.bytes(paddingSize)
      padding.copy(buffer, offset)
      offset += paddingSize
    }
  }
  
  // Fill remaining space with deterministic padding
  if (offset < targetSize) {
    const paddingRng = rng.derive('padding')
    while (offset < targetSize) {
      const chunkSize = Math.min(65536, targetSize - offset)
      const padding = paddingRng.bytes(chunkSize)
      padding.copy(buffer, offset)
      offset += chunkSize
    }
  }
  
  return buffer
}

export default generateContent
